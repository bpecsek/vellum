** What is Vellum?
Vellum is an data frame library build for Common Lisp. It is designed to be easy to both learn and use, practical and reasonably efficient. Note that this software is in beta quality at the moment.

** Mindset
The main goal of the Vellum was to create lispy data frame library, and therefore it should come with no surprise that the design is very different from a more famous Pandas for python. However, I hope to demonstrate that Vellum is a very accesible library.

** Header + Columns = Data Frame
Data Frame is composed from header and columns. Header can be thought of as a data schema, containing column names, column types and predicates for stored values and is a required to create table. Let's construct an empty data frame.

#+BEGIN_SRC common-lisp
  (defparameter *table*
    (vellum:make-table
     :header (vellum:make-header 'vellum.header:standard-header
                                 '(:alias first-column)
                                 '(:alias second-column :type fixnum))))
#+END_SRC

You may be under impression that there has to be a better way to it. You would be correct.

#+BEGIN_SRC common-lisp
  (defparameter *table*
    (vellum:make-table :columns '((:alias first-column)
                                  (:alias second-column :type fixnum))))
#+END_SRC

** Read and write data
Freshly constructed data frame is obviously empty. However, meaning of empty is somewhat blurred in vellum. Data frames are sparse in concept, meaning that they lack a natural bound. This means that although, you can locate the last non empty row...

#+BEGIN_SRC common-lisp
(print (vellum:row-count *table*)) ; => 0
#+END_SRC

But a attempt to get non-existing data won't signal error.

#+BEGIN_SRC common-lisp
(print (vellum:at *table* 5 'first-column)) ; => :NULL
;; oh, btw, column names are actually strings, meaning that this...
(print (vellum:at *table* 5 "first-column")) ; => :NULL
;; will also work. Also, this means that you don't have to import symbols just to access data.
#+END_SRC

Furthermore, VELLUM:AT is actually a setfable place which means that you can even...

#+BEGIN_SRC common-lisp
(setf (vellum:at *table* 5 'first-column) "first value")
(print (vellum:at *table* 5 'first-column)) ; => first value
(print (vellum:row-count *table*)) ; => 6
#+END_SRC

If one would want to, he could fill the content of the data frame in a loop. But that would be awkaward, wouldn't it? I suspect that you would prefer some sort of a batch method that would be handier.

** TRANFORM and BODY
This is where the TRANSFORM function and BODY macro combination comes in. The intent is to construct simple to use and universal facility to perform all kinds of row operations in a handy way. It is easy to demonstrate this on a example For instance, let's say that we want to calculate body mass index from weight and height. Formula is simple enough: weight (in kilograms) divided by height (in meters) squared. Given that our data frame already contains weight, height and BMI columns, code becomes...

#+BEGIN_SRC common-lisp
  (vellum:transform *table*
                    (vellum:body (bmi weight height)
                      (setf bmi (/ weight (* height height))))
                    :in-place t)
#+END_SRC

BODY is a macro that will expand to a lambda form with a (special) variables coresponding to the columns designated and extra boilerplate code for putting those values back into the data frame. Keyword argument :in-place allows for destructive changes. You may think that this is a bad idea sometimes given that a stray condition will leave your data messed up and I am happy to inform you that this is not the case. TRANSFORM is an exception safe function that will alter content of the table only after completion. IN-PLACE defaults to NIL anyway though.

Transform allows for a few extra tricks though. For instance, if we want to calculate BMI for individuals above certain height, we can do this by the rest of the rows. To demonstrate this idea:

#+BEGIN_SRC common-lisp
  (defparameter *above-170-only*
    (vellum:transform *table*
                      (vellum:body (bmi weight height)
                        (if (<= height 1.7)
                            (vellum:drop-row)
                            (setf bmi (/ weight (* height height))))))))
#+END_SRC

Notice that this time I've left the original frame untouched. Other keyword arguments for the transform functions are :START (the first row that should be touched, defaults to 0) and :END (1+ the last row that should be touched, defaults to the ROW-COUNT). It is possible to pass NIL as :END which will mean that the programmer decided to terminate transform manually. This is quite handy when populating an empty data frame...

#+BEGIN_SRC common-lisp
    (defparameter *table*
      (alexandria:with-input-from-file (stream "bmi data.txt")
        (vellum:transform (vellum:make-table :columns '((:alias weight)
                                                        (:alias bmi)
                                                        (:alias height)))
                          (vellum:body (weight height bmi)
                            (let ((line (read-line stream nil nil)))
                              (if (null line)
                                  (vellum:finish-transformation)
                                  (destructuring-bind ((new-weight new-height) (parse-data-line line))
                                      (setf weight new-weight
                                            height new-height
                                            bmi (/ weight (* height height))))))))))
#+END_SRC

This won't work if your data source insists on driving reading data. If API has just MAP-DATA function and no iterator you may think that you are screwed. Don't worry, there is also TRANSFORMATION that construct sort of transform iterator that you can move on your own. More of that later.

** Columns manipulation
Usually, BMI would not be present in the data frame from the start and must be somehow added. Vellum does not make it needlessly complex. Simply use NEW-COLUMNS function.

#+BEGIN_SRC common-lisp
  (defparameter *table*
    (alexandria:with-input-from-file (stream "bmi data.txt")
      (vellum:new-columns (vellum:transform (vellum:make-table :columns '((:alias weight)
                                                                          (:alias height)))
                                            (vellum:body (weight height)
                                              (let ((line (read-line stream nil nil)))
                                                (if (null line)
                                                    (vellum:finish-transformation)
                                                    (destructuring-bind (new-weight new-height) (parse-data-line line)
                                                        (setf weight new-weight
                                                              height new-height))))))
                        '(:alias bmi))))
#+END_SRC

Let's admit, this is getting a little bit nested. From now one I will use threading macro ~> from serapeum. By using this macro we are getting somewhat more undertandable form that does the exact same thing.

#+BEGIN_SRC common-lisp
  (defparameter *table*
    (alexandria:with-input-from-file (stream "bmi data.txt")
      (serapeum:~>
       (vellum:make-table :columns '((:alias weight) (:alias height)))
       (vellum:transform (vellum:body (weight height)
                           (let ((line (read-line stream nil nil)))
                             (if (null line)
                                 (vellum:finish-transformation)
                                 (destructuring-bind (new-weight new-height) (parse-data-line line)
                                     (setf weight new-weight
                                           height new-height))))))
       (vellum:new-columns '(:alias bmi))))
#+END_SRC

Either way, it is impossible to change number of columns in the table in a destructive way. This is by design as vellum headers are immutable as well.

Selecting subset of the columns is equally important to adding new columns. To do this in Vellum we should use VELLUM:SELECT function. Now, this function is slightly more complex, and it is all because of the input. For instance, to select just a single columnâ€¦

#+BEGIN_SRC common-lisp
  (defparameter *table* (vellum:make-table :columns '((:alias first-colum)
                                                      (:alias second-column)
                                                      (:alias third-column))))
  (defparameter *just-second-and-third* (vellum:select *table*
                                          :columns '(:v 1 2)))
  (defparameter *just-second-and-third* (vellum:select *table*
                                          :columns '(:v second-column :v third-column)))
  (defparameter *just-second-and-third* (vellum:select *table*
                                          :columns '(:take-from second-column :take-to third-column)))
  (defparameter *just-second-and-third* (vellum:select *table*
                                          :columns '(:take-from 1 :take-to 2)))
#+END_SRC

All four ways to select second and third columns are equally valid. :V keyword argument designates a single value, either by integer or by column alias. Pair of :TAKE-FROM and :TAKE-TO allows to select range of columns, again either by desiganting column number or column alias. Selecting by range is probably not all that useful in the context of columns, however the exact same syntax is used for :ROWS where it really it is in it's element.
